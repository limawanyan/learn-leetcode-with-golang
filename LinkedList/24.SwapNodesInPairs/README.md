# 题目

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

示例 1：
输入：head = [1,2,3,4]
输出：[2,1,4,3]
示例 2：

输入：head = []
输出：[]
示例 3：

输入：head = [1]
输出：[1]

提示：

链表中节点的数目在范围 [0, 100] 内
0 <= Node.val <= 100


进阶：你能在不修改链表节点值的情况下解决这个问题吗?（也就是说，仅修改节点本身。）

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/swap-nodes-in-pairs
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

# 解题思路
### 递归 
    https://lyl0724.github.io/2020/01/25/1/
    1.找整个递归的终止条件，递归应该在什么结束？
    当链表只剩一个节点或者没有节点的时候，没得交换了递归终止
    2.找返回值，应该给上一级返回什么信息
    两两交换链表中相邻的节点，因此自然希望交换给上一级递归的是已经处理好的链表
    3.本级递归应该作什么，在这一级递归中，应该完成什么任务？
    三个节点：head、head.next、已处理完的链表部分。本级递归的任务就是交换这三个节点中的前两个节点

### 迭代
    1.创建一个哑结点dummyHead，赋值为第一个节点head
    2.初始化temp = dummyHead
    3.temp随着迭代next不断指向下一个节点
    4.当temp.Next和temp.Next.Next等于空，说明没有可以两两交换的节点了
    5.交换之前关系为：temp -> node1 -> node2
    6.交换后关系为：temp -> node2 -> node1
    7.再将temp = node1 继续进行迭代
